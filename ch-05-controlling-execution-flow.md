### Выражение if

Конструкция `if` в Zig используется для выполнения блока кода на основе определённого условия. В Zig она позволяет избежать множества потенциальных ошибок благодаря своей строгой грамматике.

```zig
const std = @import("std");

pub fn main() void {
    if (2 + 2 == 4) {
        std.debug.print("{}\n", .{4});
    }
    if (2 + 2 != 5) {
        std.debug.print("{}\n", .{5});
    }
    if ('2' > '1') {
        std.debug.print("{}\n", .{2});
    }
    if (true) {
        std.debug.print("{}\n", .{true});
    }
    if (false) {
        std.debug.print("{}\n", .{false});
    }
}
```

Обратите внимание, что в Zig условие `if` обязательно должно быть окружено скобками, и фигурные скобки для блока кода также обязательны. Это обеспечивает чёткую и предсказуемую структуру кода.

#### Домашнее задание
Попробуйте создать рекурсивную функцию с использованием `if`, которая вызвала бы переполнение стека. Это поможет лучше понять, как Zig управляет рекурсией и ограничениями стековой памяти.

### Выражение if-else и else-if

Условные выражения в Zig также могут поддерживать цепочку условий с помощью `else` и `else if`, что позволяет эффективно управлять разными ветвями логики.

```zig
const std = @import("std");

pub fn main() void {
    const n = 0;
    // const n = 1;
    // const n = 10 * 1000;
    // const n = -1;

    if (n > 5000) {
        std.debug.print("Это число большое\n", .{});
    } else if (n > 0) {
        std.debug.print("А это число небольшое\n", .{});
    } else if (n < 0) {
        std.debug.print("А это число отрицательное\n", .{});
    } else {
        std.debug.print("А это ноль.\n", .{});
    }
}
```

## Цикл while

Цикл `while` в Zig выполняет блок кода, пока условие истинно. Он позволяет повторять выполнение блока, основываясь на логическом условии.

```zig
const std = @import("std");

pub fn main() void {
    var j: i32 = 0;
    while (j <= 256) {
        std.debug.print("{} ", .{ j * j });
        j += 1;
    }
    std.debug.print("\n", .{});
}
```

### Домашнее задание
Попробуйте инициализировать переменную внутри цикла `while` и наблюдайте за её изменениями. Задайте вопросы и пытайтесь найти на них ответы, углубляясь в особенности языка Zig.

### Прерывание цикла: break и continue

Zig поддерживает ключевые слова `break` и `continue` для управления выполнением циклов.

#### break

`break` используется для немедленного выхода из цикла:

```zig
const std = @import("std");

pub fn main() void {
    var j: i32 = 0;
    while (j < 256) {
        const k = j * j;
        j += 1;
        std.debug.print("{} ", .{k});
        if (k >= 40000) {
            break;
        }
    }
    std.debug.print("\n", .{});
}
```

#### continue

`continue` используется для перехода к следующей итерации цикла:

```zig
const std = @import("std");

pub fn main() void {
    var j: i32 = 0; 
    while (j <= 256) { 
        j += 1; 
        if (@rem(j, 2) == 0) { // Используем @rem для операции деления с остатком
            continue; 
        } 
        std.debug.print("{} ", .{j * j}); 
    }
    std.debug.print("\n", .{});
}
```

## Бесконечный цикл loop

В Zig вы можете создать бесконечный цикл с использованием `while (true)` или с помощью метки `:void` в сочетании с `break` для выхода:

```zig
const std = @import("std");

pub fn main() void {
    var j: i32 = 0;
    loop: while (true) {
        std.debug.print("{} ", .{j * j});
        j += 1;
        if (j == 200) {
            break :loop;
        }
    }
    std.debug.print("\n", .{});
}
```

## Цикл for

В Zig цикл `for` используется для перебора элементов коллекций и числовых диапазонов:

```zig
const std = @import("std");

pub fn main() void {
    for (1..11) |i| {
        std.debug.print("{} ", .{i});
    }
    std.debug.print("\n", .{});
}
```

В этом примере диапазон `1..11` используется для итерации от 1 до 10. Переменная `i` инициализируется для каждой итерации. В Zig можно также использовать `for` для перебора массивов или списков.

### Домашнее задание

Напишите программы с циклом `for`, которые используют различные типы данных Zig. Используйте операторы `break` и `continue` для управления потоком выполнения. Исследуйте различные способы итерации и условия выхода из циклов.
