### Работа с последовательностями данных в языке программирования Zig

Язык программирования Zig предоставляет мощные инструменты для работы с последовательностями данных, включая массивы, срезы и строки. Эти конструкции являются основой для обработки упорядоченных данных и обеспечивают высокую производительность и контроль над управлением памятью. В данной статье мы рассмотрим, как работать с последовательностями данных в Zig, используя примеры и объяснения.

---

### **1. Массивы в Zig**

Массивы в Zig — это статически типизированные структуры фиксированной длины. Они позволяют хранить элементы одного типа в непрерывной области памяти. Размер массива известен на этапе компиляции.

#### Пример объявления массива:
```zig
const std = @import("std");

pub fn main() void {
    const numbers: [5]u32 = [5]u32{1, 2, 3, 4, 5};
    std.debug.print("Массив: {}\n", .{numbers});
}
```

В данном примере массив `numbers` содержит пять элементов типа `u32`. Попытка обратиться к индексу за пределами массива приведёт к ошибке на этапе выполнения (если активна проверка границ массива).

#### Итерация по массиву:
```zig
pub fn main() void {
    const numbers: [5]u32 = [5]u32{1, 2, 3, 4, 5};

    for (numbers) |num, index| {
        std.debug.print("Элемент {}: {}\n", .{index, num});
    }
}
```

Здесь используется цикл `for`, который позволяет получить как элемент массива, так и его индекс.

---

### **2. Срезы (slices)**

Срезы в Zig — это гибкие представления массива, которые позволяют работать с частью массива или динамическими последовательностями данных. В отличие от массивов, длина среза может быть неизвестна на этапе компиляции.

#### Пример создания среза:
```zig
pub fn main() void {
    var buffer: [10]u8 = [_]u8{0} ** 10; // Массив из 10 элементов, инициализированных нулями
    const slice: []const u8 = buffer[0..5]; // Срез первых пяти элементов

    std.debug.print("Срез: {}\n", .{slice});
}
```

Срезы определяются с помощью синтаксиса `array[start..end]`, где `start` — начальный индекс, а `end` — индекс конца (не включается в срез).

#### Изменение данных через срез:
```zig
pub fn main() void {
    var buffer: [10]u8 = [_]u8{0} ** 10;
    var slice: []u8 = buffer[2..7];

    for (slice) |*value| {
        value.* = 42; // Изменяем все элементы на 42
    }

    std.debug.print("Массив после изменения: {}\n", .{buffer});
}
```

Срезы позволяют изменять элементы массива, если они объявлены как изменяемые (`var`).

---

### **3. Строки**

В Zig строки представляют собой последовательности байтов (тип `[]u8` или `[]const u8`), где длина строки не закодирована внутри самой строки. Это даёт высокий уровень контроля над использованием памяти.

#### Создание строки:
```zig
pub fn main() void {
    const hello: []const u8 = "Hello, Zig!";
    std.debug.print("{}\n", .{hello});
}
```

#### Работа с символами:
```zig
pub fn main() void {
    const text: []const u8 = "ZigLang";

    for (text) |char, index| {
        std.debug.print("Символ {}: {}\n", .{index, char});
    }
}
```

Строки в Zig представляют собой срезы неизменяемых байтов, поэтому можно безопасно итерироваться по ним, не боясь повредить данные.

#### Конкатенация строк:
Для объединения строк в Zig используется библиотека `std.mem.concat`.

```zig
const std = @import("std");

pub fn main() void {
    const part1 = "Hello";
    const part2 = ", Zig!";
    const allocator = std.heap.page_allocator;

    const result = try std.mem.concat(allocator, part1, part2);
    defer allocator.free(result);

    std.debug.print("{}\n", .{result});
}
```

---

### **4. Динамические последовательности с помощью `std.ArrayList`**

Для работы с динамическими последовательностями данных Zig предоставляет структуру `std.ArrayList`, которая позволяет добавлять и удалять элементы во время выполнения.

#### Пример использования `std.ArrayList`:
```zig
const std = @import("std");

pub fn main() !void {
    const allocator = std.heap.page_allocator;

    var list = std.ArrayList(u32).init(allocator);
    defer list.deinit();

    try list.append(1);
    try list.append(2);
    try list.append(3);

    for (list.items) |item| {
        std.debug.print("{}\n", .{item});
    }
}
```

Здесь мы создаём динамический список чисел, добавляем элементы и затем итерируемся по ним.

---

### **5. Управление памятью**

Одной из ключевых особенностей Zig является управление памятью. Для динамических последовательностей вы можете использовать пользовательский аллокатор, обеспечивая контроль над выделением и освобождением памяти.

#### Пример использования пользовательского аллокатора:
```zig
const std = @import("std");

pub fn main() !void {
    const allocator = std.heap.page_allocator;

    var list = std.ArrayList(u8).init(allocator);
    defer list.deinit();

    try list.ensureCapacity(10); // Резервируем место под 10 элементов
    for (0..10) |i| {
        try list.append(@intCast(u8, i));
    }

    std.debug.print("Данные: {}\n", .{list.items});
}
```

Использование выделителя памяти позволяет избежать утечек памяти и гарантировать оптимальное использование ресурсов.

## Домашнее задание
Напишите программы с использованием массивов и векторов. Передавай данные между объектами, меняйте их, добавляйте и удаляйте.

---

### **Заключение**

Работа с последовательностями данных в Zig строится вокруг статически типизированных массивов, гибких срезов и мощных инструментов, таких как `std.ArrayList`. Эти конструкции обеспечивают гибкость, высокую производительность и полный контроль над памятью. Zig предлагает удобный синтаксис и встроенные механизмы для безопасного и эффективного программирования. Используя массивы, срезы и строки, вы сможете решать широкий спектр задач, от обработки данных до создания производительных приложений.
